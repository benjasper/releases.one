// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const createRepository = `-- name: CreateRepository :exec
INSERT INTO
  repositories (
    github_id,
    name,
    url,
    image_url,
    image_size,
    private,
    created_at,
    updated_at,
    last_synced_at,
    hash
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateRepositoryParams struct {
	GithubID     string
	Name         string
	Url          string
	ImageUrl     string
	ImageSize    int32
	Private      bool
	CreatedAt    time.Time
	UpdatedAt    time.Time
	LastSyncedAt time.Time
	Hash         uint64
}

func (q *Queries) CreateRepository(ctx context.Context, arg CreateRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, createRepository,
		arg.GithubID,
		arg.Name,
		arg.Url,
		arg.ImageUrl,
		arg.ImageSize,
		arg.Private,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastSyncedAt,
		arg.Hash,
	)
	return err
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO
  users (github_id, username, github_token, last_synced_at)
VALUES
  (?, ?, ?, ?)
`

type CreateUserParams struct {
	GithubID     uint64
	Username     string
	GithubToken  GitHubToken
	LastSyncedAt time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.GithubID,
		arg.Username,
		arg.GithubToken,
		arg.LastSyncedAt,
	)
}

const deleteReleasesOlderThan = `-- name: DeleteReleasesOlderThan :execresult
DELETE FROM releases
WHERE
  released_at < ?
  AND repository_id = ?
ORDER BY
  released_at DESC
`

type DeleteReleasesOlderThanParams struct {
	ReleasedAt   time.Time
	RepositoryID int32
}

func (q *Queries) DeleteReleasesOlderThan(ctx context.Context, arg DeleteReleasesOlderThanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteReleasesOlderThan, arg.ReleasedAt, arg.RepositoryID)
}

const deleteRepositoryStarsUpdatedBefore = `-- name: DeleteRepositoryStarsUpdatedBefore :execresult
DELETE FROM repository_stars
WHERE
  updated_at < ?
  AND user_id = ?
`

type DeleteRepositoryStarsUpdatedBeforeParams struct {
	UpdatedAt time.Time
	UserID    int32
}

func (q *Queries) DeleteRepositoryStarsUpdatedBefore(ctx context.Context, arg DeleteRepositoryStarsUpdatedBeforeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteRepositoryStarsUpdatedBefore, arg.UpdatedAt, arg.UserID)
}

const getReleases = `-- name: GetReleases :many
SELECT
  github_id, id, repository_id, name, url, tag_name, description, description_short, author, is_prerelease, released_at, created_at, updated_at, hash
FROM
  releases
WHERE
  repository_id = ?
ORDER BY
  released_at DESC
`

func (q *Queries) GetReleases(ctx context.Context, repositoryID int32) ([]Release, error) {
	rows, err := q.db.QueryContext(ctx, getReleases, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Release
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.GithubID,
			&i.ID,
			&i.RepositoryID,
			&i.Name,
			&i.Url,
			&i.TagName,
			&i.Description,
			&i.DescriptionShort,
			&i.Author,
			&i.IsPrerelease,
			&i.ReleasedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReleasesForUser = `-- name: GetReleasesForUser :many
SELECT
  ` + "`" + `releases` + "`" + `.` + "`" + `id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `github_id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `name` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `url` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `tag_name` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `description` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `description_short` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `author` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `is_prerelease` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `released_at` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `created_at` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `updated_at` + "`" + `,
  ` + "`" + `repositories` + "`" + `.` + "`" + `name` + "`" + ` AS repository_name,
  ` + "`" + `repositories` + "`" + `.` + "`" + `image_url` + "`" + ` AS image_url,
  ` + "`" + `repositories` + "`" + `.` + "`" + `image_size` + "`" + ` AS image_size,
  ` + "`" + `repositories` + "`" + `.` + "`" + `github_id` + "`" + ` AS repository_github_id
FROM
  ` + "`" + `releases` + "`" + `
  LEFT JOIN ` + "`" + `repositories` + "`" + ` ON ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + ` = ` + "`" + `repositories` + "`" + `.` + "`" + `id` + "`" + `
  INNER JOIN ` + "`" + `repository_stars` + "`" + ` ON ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + ` = ` + "`" + `repository_stars` + "`" + `.` + "`" + `repository_id` + "`" + `
WHERE
  ` + "`" + `repository_stars` + "`" + `.` + "`" + `user_id` + "`" + ` = ?
ORDER BY
  releases.released_at DESC
LIMIT
  100
`

type GetReleasesForUserRow struct {
	ID                 int32
	GithubID           string
	RepositoryID       int32
	Name               string
	Url                string
	TagName            string
	Description        string
	DescriptionShort   string
	Author             sql.NullString
	IsPrerelease       bool
	ReleasedAt         time.Time
	CreatedAt          time.Time
	UpdatedAt          time.Time
	RepositoryName     sql.NullString
	ImageUrl           sql.NullString
	ImageSize          sql.NullInt32
	RepositoryGithubID sql.NullString
}

func (q *Queries) GetReleasesForUser(ctx context.Context, userID int32) ([]GetReleasesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getReleasesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReleasesForUserRow
	for rows.Next() {
		var i GetReleasesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.GithubID,
			&i.RepositoryID,
			&i.Name,
			&i.Url,
			&i.TagName,
			&i.Description,
			&i.DescriptionShort,
			&i.Author,
			&i.IsPrerelease,
			&i.ReleasedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RepositoryName,
			&i.ImageUrl,
			&i.ImageSize,
			&i.RepositoryGithubID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReleasesForUserShortDescription = `-- name: GetReleasesForUserShortDescription :many
SELECT
  ` + "`" + `releases` + "`" + `.` + "`" + `id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `github_id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `name` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `url` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `tag_name` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `description_short` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `author` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `is_prerelease` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `released_at` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `created_at` + "`" + `,
  ` + "`" + `releases` + "`" + `.` + "`" + `updated_at` + "`" + `,
  ` + "`" + `repositories` + "`" + `.` + "`" + `name` + "`" + ` AS repository_name,
  ` + "`" + `repositories` + "`" + `.` + "`" + `image_url` + "`" + ` AS image_url,
  ` + "`" + `repositories` + "`" + `.` + "`" + `image_size` + "`" + ` AS image_size
FROM
  ` + "`" + `releases` + "`" + `
  LEFT JOIN ` + "`" + `repositories` + "`" + ` ON ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + ` = ` + "`" + `repositories` + "`" + `.` + "`" + `id` + "`" + `
  INNER JOIN ` + "`" + `repository_stars` + "`" + ` ON ` + "`" + `releases` + "`" + `.` + "`" + `repository_id` + "`" + ` = ` + "`" + `repository_stars` + "`" + `.` + "`" + `repository_id` + "`" + `
WHERE
  ` + "`" + `repository_stars` + "`" + `.` + "`" + `user_id` + "`" + ` = ?
ORDER BY
  releases.released_at DESC
LIMIT
  100
`

type GetReleasesForUserShortDescriptionRow struct {
	ID               int32
	GithubID         string
	RepositoryID     int32
	Name             string
	Url              string
	TagName          string
	DescriptionShort string
	Author           sql.NullString
	IsPrerelease     bool
	ReleasedAt       time.Time
	CreatedAt        time.Time
	UpdatedAt        time.Time
	RepositoryName   sql.NullString
	ImageUrl         sql.NullString
	ImageSize        sql.NullInt32
}

func (q *Queries) GetReleasesForUserShortDescription(ctx context.Context, userID int32) ([]GetReleasesForUserShortDescriptionRow, error) {
	rows, err := q.db.QueryContext(ctx, getReleasesForUserShortDescription, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReleasesForUserShortDescriptionRow
	for rows.Next() {
		var i GetReleasesForUserShortDescriptionRow
		if err := rows.Scan(
			&i.ID,
			&i.GithubID,
			&i.RepositoryID,
			&i.Name,
			&i.Url,
			&i.TagName,
			&i.DescriptionShort,
			&i.Author,
			&i.IsPrerelease,
			&i.ReleasedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RepositoryName,
			&i.ImageUrl,
			&i.ImageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepositoryByGithubID = `-- name: GetRepositoryByGithubID :one
SELECT
  id, github_id, name, url, private, created_at, updated_at, last_synced_at, image_url, image_size, hash
FROM
  repositories
WHERE
  github_id = ?
`

func (q *Queries) GetRepositoryByGithubID(ctx context.Context, githubID string) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getRepositoryByGithubID, githubID)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Name,
		&i.Url,
		&i.Private,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastSyncedAt,
		&i.ImageUrl,
		&i.ImageSize,
		&i.Hash,
	)
	return i, err
}

const getUserByGitHubID = `-- name: GetUserByGitHubID :one
SELECT
  id, username, github_id, github_token, last_synced_at, public_id
FROM
  users
WHERE
  github_id = ?
`

func (q *Queries) GetUserByGitHubID(ctx context.Context, githubID uint64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByGitHubID, githubID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.GithubID,
		&i.GithubToken,
		&i.LastSyncedAt,
		&i.PublicID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
  id, username, github_id, github_token, last_synced_at, public_id
FROM
  users
WHERE
  id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.GithubID,
		&i.GithubToken,
		&i.LastSyncedAt,
		&i.PublicID,
	)
	return i, err
}

const getUserByPublicID = `-- name: GetUserByPublicID :one
SELECT
  id, username, github_id, github_token, last_synced_at, public_id
FROM
  users
WHERE
  public_id = ?
`

func (q *Queries) GetUserByPublicID(ctx context.Context, publicID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPublicID, publicID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.GithubID,
		&i.GithubToken,
		&i.LastSyncedAt,
		&i.PublicID,
	)
	return i, err
}

const getUsersInNeedOfAnUpdate = `-- name: GetUsersInNeedOfAnUpdate :many
SELECT
  id, username, github_id, github_token, last_synced_at, public_id
FROM
  users
WHERE
  last_synced_at < ?
`

func (q *Queries) GetUsersInNeedOfAnUpdate(ctx context.Context, lastSyncedAt time.Time) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersInNeedOfAnUpdate, lastSyncedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.GithubID,
			&i.GithubToken,
			&i.LastSyncedAt,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRelease = `-- name: InsertRelease :exec
INSERT INTO
  releases (
    github_id,
    repository_id,
    name,
    author,
    tag_name,
    url,
    description,
    description_short,
    hash,
    released_at,
    created_at,
    updated_at,
    is_prerelease
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertReleaseParams struct {
	GithubID         string
	RepositoryID     int32
	Name             string
	Author           sql.NullString
	TagName          string
	Url              string
	Description      string
	DescriptionShort string
	Hash             uint64
	ReleasedAt       time.Time
	CreatedAt        time.Time
	UpdatedAt        time.Time
	IsPrerelease     bool
}

func (q *Queries) InsertRelease(ctx context.Context, arg InsertReleaseParams) error {
	_, err := q.db.ExecContext(ctx, insertRelease,
		arg.GithubID,
		arg.RepositoryID,
		arg.Name,
		arg.Author,
		arg.TagName,
		arg.Url,
		arg.Description,
		arg.DescriptionShort,
		arg.Hash,
		arg.ReleasedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.IsPrerelease,
	)
	return err
}

const insertRepositoryStar = `-- name: InsertRepositoryStar :exec
INSERT INTO
  repository_stars (repository_id, user_id, created_at, updated_at)
VALUES
  (?, ?, ?, ?)
`

type InsertRepositoryStarParams struct {
	RepositoryID int32
	UserID       int32
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

func (q *Queries) InsertRepositoryStar(ctx context.Context, arg InsertRepositoryStarParams) error {
	_, err := q.db.ExecContext(ctx, insertRepositoryStar,
		arg.RepositoryID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const updateRelease = `-- name: UpdateRelease :execresult
UPDATE releases
SET
  github_id = ?,
  name = ?,
  url = ?,
  description = ?,
  description_short = ?,
  author = ?,
  is_prerelease = ?,
  released_at = ?,
  updated_at = ?,
  hash = ?
WHERE
  id = ?
`

type UpdateReleaseParams struct {
	GithubID         string
	Name             string
	Url              string
	Description      string
	DescriptionShort string
	Author           sql.NullString
	IsPrerelease     bool
	ReleasedAt       time.Time
	UpdatedAt        time.Time
	Hash             uint64
	ID               int32
}

func (q *Queries) UpdateRelease(ctx context.Context, arg UpdateReleaseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateRelease,
		arg.GithubID,
		arg.Name,
		arg.Url,
		arg.Description,
		arg.DescriptionShort,
		arg.Author,
		arg.IsPrerelease,
		arg.ReleasedAt,
		arg.UpdatedAt,
		arg.Hash,
		arg.ID,
	)
}

const updateRepository = `-- name: UpdateRepository :execresult
UPDATE repositories
SET
  url = ?,
  image_url = ?,
  image_size = ?,
  private = ?,
  created_at = ?,
  updated_at = ?,
  last_synced_at = ?,
  hash = ?
WHERE
  id = ?
`

type UpdateRepositoryParams struct {
	Url          string
	ImageUrl     string
	ImageSize    int32
	Private      bool
	CreatedAt    time.Time
	UpdatedAt    time.Time
	LastSyncedAt time.Time
	Hash         uint64
	ID           int32
}

func (q *Queries) UpdateRepository(ctx context.Context, arg UpdateRepositoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateRepository,
		arg.Url,
		arg.ImageUrl,
		arg.ImageSize,
		arg.Private,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastSyncedAt,
		arg.Hash,
		arg.ID,
	)
}

const updateRepositoryStar = `-- name: UpdateRepositoryStar :execresult
UPDATE repository_stars
SET
  updated_at = ?
WHERE
  repository_id = ?
  AND user_id = ?
`

type UpdateRepositoryStarParams struct {
	UpdatedAt    time.Time
	RepositoryID int32
	UserID       int32
}

func (q *Queries) UpdateRepositoryStar(ctx context.Context, arg UpdateRepositoryStarParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateRepositoryStar, arg.UpdatedAt, arg.RepositoryID, arg.UserID)
}

const updateUserPublicID = `-- name: UpdateUserPublicID :exec
UPDATE users
SET
  public_id = ?
WHERE
  id = ?
`

type UpdateUserPublicIDParams struct {
	PublicID sql.NullString
	ID       int32
}

func (q *Queries) UpdateUserPublicID(ctx context.Context, arg UpdateUserPublicIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPublicID, arg.PublicID, arg.ID)
	return err
}

const updateUserSyncedAt = `-- name: UpdateUserSyncedAt :exec
UPDATE users
SET
  last_synced_at = ?
WHERE
  id = ?
`

type UpdateUserSyncedAtParams struct {
	LastSyncedAt time.Time
	ID           int32
}

func (q *Queries) UpdateUserSyncedAt(ctx context.Context, arg UpdateUserSyncedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSyncedAt, arg.LastSyncedAt, arg.ID)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users
SET
  github_token = ?
WHERE
  id = ?
`

type UpdateUserTokenParams struct {
	GithubToken GitHubToken
	ID          int32
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateUserToken, arg.GithubToken, arg.ID)
	return err
}
